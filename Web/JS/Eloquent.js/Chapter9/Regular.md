# 正则表达式(Regular expression)

正则表达式是检查, 处理字符串的强力工具

## 创建

`RegExp Contructor`: 将模式书写成普通字符串


`//`: 表达式中`/`, 特殊字符(`?` `+`)需要转义

## 匹配测试

`RegExp.test("string")`

## 字符集

`[0-9]` `-`指定一个字符范围, 顺序由`Unicode`码决定

* `\d` 任意数字
* `\w` 字母和数字符号(单词?)
* `\s` 任意空白符号(空格, tab, 换行等)
* `\D` 非数字符号
* `\W` 非字母和数字符号
* `\S` 非空白
* `.` 换行符以外任意符号

`[]` 特殊字符会失去正则中的特殊含义(. + ?...)

`[^01]` `^`排除某个字符集

## 部分模式重复

`+` 该元素至少重复一次

`*` 元素出现0次或多次

`?` 模式可选, 出现0次或1次

`{1,4} {1}` 指明出现的次数, 可以使用两个数字指定一个范围, 也可省略一次数字(`{,5} {6,}`)

## 子表达式分组

`(hoo+)+` 一次性对多个元素使用`+`, `?` 等元素, 使用`()`创建一个分组. 对于符号来说, `()`内算作单个元素

## 匹配和分组

`exec()`(execute 执行) 无法匹配模式则返回`null`, 否则返回表示匹配字符串信息的对象

`/\d+/.exec("one two 100")` -> `[ '100', index: 8, input: 'one two 100' ]`

匹配的字符串, `index` 匹配成功的起始位置, `input`

`string.match()` 返回相同内容

若regexp中包含子表达式分组(`()`), 与分组匹配的子字符串也会返回到数组中; 分组中没有匹配任何字符串, 则数组中对应元素为`undefined`; 匹配多个则只返回子表达式分组最后匹配的元素

`exec()`常用于提取字符串

## 日期 Date class

`new Date()` 从0开始表示月份, 1开始表示日期

可以传入毫秒数(1970开始, 之前的时间可以使用负数)创建时间, `.getTime()` 返回毫秒数

`getFullYear()` `getMonth()` `getDate()` `getHours` `getMinutes` `getSeconds` ... 提取时间中特定值

使用多个正则分组从字符串中提取出特定值(`_`跳过exec中分组返回值)

## 单词和字符串边界

`^` 表示输入字符串起始位置; `$` 表示字符串结束位置 `\^\d+$\` 完整匹配一个或多个数字组成的数组

`\b` 确保正则匹配的字符串起始或结束位置在单词边界上

## 选项模式

`|` 表示任选左侧或右侧表达式进行比配(或), 可以搭配`()`分组使用

## 匹配原理

使用`exec`或`test`时, 正则表达式引擎在字符串中寻找匹配, 从字符串的开头开始匹配表达式, 逐个移动, 直到找到匹配的字符串或达到末尾, 然后返回第一个找到的匹配或没有任何匹配

## 回溯

在有多个分支的正则表达式匹配时, 表达式发现进入错误的分支时就会进行回溯, 返回到进入分支前的位置重新匹配

处理重复模式时(`+` `*`) 首先会尝试匹配最大限度的字符串, 然后根据后面的条件进行回溯, 找到匹配的字符串.

注意不要编写包含大量回溯的正则表达式

## replace

`repalce(/regexp/g, "a")`

## 贪婪模式

```js
//返回 11, 而非 1 + 1
console.log(stripComments("1/* a */+/* b */1"));
```
表达式会先匹配整个剩余字符串(`/*`之后), 然后进行回溯到`*/1` 就会完成匹配, 而非单独匹配两个注释

模式重复运算符(`+` `*` `?`)是贪婪的