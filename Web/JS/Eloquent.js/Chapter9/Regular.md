# 正则表达式(Regular expression)

正则表达式是检查, 处理字符串的强力工具

## 创建

`RegExp Contructor`: 将模式书写成普通字符串


`//`: 表达式中`/`, 特殊字符(`?` `+`)需要转义

## 匹配测试

`RegExp.test("string")`

## 字符集

`[0-9]` `-`指定一个字符范围, 顺序由`Unicode`码决定

* `\d` 任意数字
* `\w` 字母和数字符号(单词?)
* `\s` 任意空白符号(空格, tab, 换行等)
* `\D` 非数字符号
* `\W` 非字母和数字符号
* `\S` 非空白
* `.` 换行符以外任意符号

`[]` 特殊字符会失去正则中的特殊含义(. + ?...)

`[^01]` `^`排除某个字符集

## 部分模式重复

`+` 该元素至少重复一次

`*` 元素出现0次或多次

`?` 模式可选, 出现0次或1次

`{1,4} {1}` 指明出现的次数, 可以使用两个数字指定一个范围, 也可省略一次数字(`{,5} {6,}`)

## 子表达式分组

`(hoo+)+` 一次性对多个元素使用`+`, `?` 等元素, 使用`()`创建一个分组. 对于符号来说, `()`内算作单个元素

## 匹配和分组

`exec()`(execute 执行) 无法匹配模式则返回`null`, 否则返回表示匹配字符串信息的对象

`/\d+/.exec("one two 100")` -> `[ '100', index: 8, input: 'one two 100' ]`

匹配的字符串, `index` 匹配成功的起始位置, `input`

`string.match()` 返回相同内容

若regexp中包含子表达式分组(`()`), 与分组匹配的子字符串也会返回到数组中; 分组中没有匹配任何字符串, 则数组中对应元素为`undefined`; 匹配多个则只返回子表达式分组最后匹配的元素

`exec()`常用于提取字符串

## 日期 Date class

`new Date()` 从0开始表示月份, 1开始表示日期

可以传入毫秒数(1970开始, 之前的时间可以使用负数)创建时间, `.getTime()` 返回毫秒数

`getFullYear()` `getMonth()` `getDate()` `getHours` `getMinutes` `getSeconds` ... 提取时间中特定值

使用多个正则分组从字符串中提取出特定值(`_`跳过exec中分组返回值)

## 单词和字符串边界

`^` 表示输入字符串起始位置; `$` 表示字符串结束位置 `\^\d+$\` 完整匹配一个或多个数字组成的数组

`\b` 确保正则匹配的字符串起始或结束位置在单词边界上

## 选项模式

`|` 表示任选左侧或右侧表达式进行比配(或), 可以搭配`()`分组使用

## 匹配原理

使用`exec`或`test`时, 正则表达式引擎在字符串中寻找匹配, 从字符串的开头开始匹配表达式, 逐个移动, 直到找到匹配的字符串或达到末尾, 然后返回第一个找到的匹配或没有任何匹配

## 回溯

在有多个分支的正则表达式匹配时, 表达式发现进入错误的分支时就会进行回溯, 返回到进入分支前的位置重新匹配

处理重复模式时(`+` `*`) 首先会尝试匹配最大限度的字符串, 然后根据后面的条件进行回溯, 找到匹配的字符串.

注意不要编写包含大量回溯的正则表达式

## replace

`repalce(/regexp/g, "a")`

## 贪婪模式

```js
//返回 11, 而非 1 + 1
console.log(stripComments("1/* a */+/* b */1"));
```
表达式会先匹配整个剩余字符串(`/*`之后), 然后进行回溯到`*/1` 就会完成匹配, 而非单独匹配两个注释

模式重复运算符(`+` `*` `?`)是贪婪的, 尽可能多地匹配它们可以匹配的字符, 然后回溯
如果在重复运算符后加`?` 会将它们变为非贪婪的, 会尽量少匹配字符

## 动态创建RegExp Object

`new RegExp()` 使用字符串创建正则, 第二个参数为表达式选项(`g` `i`)

## search

`search()` 传递一个正则表达式, 返回首先匹配的表达式索引, 没有则返回-1, 但无法指定起始偏移位置

## lastIndex

正则表达式对象包含`source`(包含正则表达式字符串) `lastIndex`(匹配的起始位置, 每次成功匹配会更新, 匹配失败则清零)

粘性选项`y` 只有直接从lastIndex开始处进行匹配才会成功

对一个正则使用多次`exec`调用时, `lastIndex`更新可能会导致问题

`match()`使用全局选项(`g`)时, 会返回所有匹配的字符串

## 循环匹配

`while(match=number.exec(input))` 无法找到更多匹配时返回null结束循环

## 解析INI文件

`INI`文件
* 忽略空行和以分号起始的行
* 使用`[]`包围的行表示一个新的节(`section`)
* 行中是一个标识符(字母和数字), 后面跟着`=` 表示向当前节添加选项
* 其他格式无效

## 国际化字符

单词字符`\w`只是26个拉丁字母(大小写)和数字, 下划线. 而其他单词则无法匹配`\w`(会匹配`\W`)

正则处理Unicode?

