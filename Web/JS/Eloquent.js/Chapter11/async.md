# 异步编程

## 异步

同步编程模型中, 一次只发生一件事. 当你调用执行长时间操作的函数时, 它只会在操作完成时返回, 等待操作时停止执行程序

异步模型允许同时发生多个事件. 开始一个操作时, 程序依然会继续向下执行, 当动作结束时, 程序会得到通知和结果

当在网络中进行多个请求时

同步模型中, 要逐个创建请求, 等待前一个请求返回时, 下一个请求才会继续执行; 解决此问题要启动额外的控制线程(另一个正在运行的程序, 多个线程可能同时运行在不同处理器上?).第二个线程可以启动第二个请求, 然后多个线程等待它们的结果返回, 在重新同步组合结果.

## 回调 callback

使执行慢动作的函数接受额外的参数(回调函数); 使用操作返回的结果调用回调函数

如果使用请求处理器的返回值作为响应值, 意味着请求处理器本身不能执行异步操作. 执行异步工作的函数通常会在完成工作之前返回, 安排回调函数在完成时调用

## Promise ?

`Promise` 异步行为, 可以在某个时刻完成并产生一个值. 值可用时, 可以通知任何感兴趣的人

`Promise.resolve` 创建 `Promise`

## 故障

常规的`JS`计算可能会抛出异常而失败. 异步计算也是同样, 确保将故障正确地报告给回调函数, 是非常困难的

广泛的约定是: 回调函数的第一个参数用于指示操作失败, 第二个参数包含成功时产生的值

`Promise`简化了操作, 当请求处理抛出错误时, 自动使`then`调用产生的`Promise`被拒绝
如果异步操作中的任何元素失效, 则整个链的结果会被拒绝, 并且不会调用失败位置之后的任何请求处理

`Promise.reject`会创建一个新的, 立即被拒绝的`Promise`

`Promise.catch()`注册一个请求处理, 被拒绝时调用, 正常解析原始`Promise`值, 发生错误时, 调用请求处理的结果. 如果`catch`抛出错误, 新的`Promise`也同样会被拒绝

简写, `then`还接受错误处理作为第二个参数

## 网络泛洪

将信息广播到整个网络

设置一种自动转发给相邻的请求, 然后这些相邻部分又转发给各自的相邻部分, 直到整个网络收到这个消息

避免永远在网络上发送相同的消息, 每个部分都保留已收到的消息, 当收到重复消息时, 忽略它. 收到新消息时, 则进行转发

## 消息路由

图 搜索到达网络中给定节点的路线. 但不是返回整个路线, 而是返回下一步