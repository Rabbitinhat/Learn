# Function

将一段程序包装成值的概念有很多用途. 它为我们提供了方法, 用于构建更大的程序, 减少重复, 将名称和子程序相关联, 以及将子程序相互隔离

## 创建函数
不带表达式的`renturn`语句, 或省略`return`, 函数返回`undefined`

## 绑定和作用域

每个绑定(变量)都有一个作用域, 它是程序的一部分, 其中变量是可见的. 对于在任何函数或块之外定义的变量, 作用域是整个函数-可以在任何地方引用该变量, 称为全局的(globel)

但是为函数参数创建的, 或在函数内部声明的变量, 只能在该函数中引用, 所以称它们为局部变量(local variable). 每次调用该函数时, 都会创建这些变量的新实例. 这提供了函数之间的一些隔离

用`let`和`const`声明的绑定, 实际上是它们的声明所在的块(`block`)的局部对象

每个局部作用域也可以看到所有包含它的局部作用域. 块内可见的绑定集, 由这个块在程序文本中的位置决定. 每个局部作用域也可以看到包含它的所有局部作用域, 并且所有作用域都可以看到全局作用域. 这种绑定可见性方法称为词法作用域

### 调用栈

```js
function greet(who){
    console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");
```

控制流

```js
//NOTE 当调用greet时(greet("Harry"))
not in function
    in greet
        in console.log
    in greet
//NOTE greet调用结束
not in function
    in console.log
not in function
```

由于函数在返回时必须跳回调用它的地方, 因此计算机必须记住调用发生处上下文(context).

计算机存储此上下文的地方是调用栈(`Stack` LIFO). 每次调用函数时, 当前上下文都存储在此栈的顶部. 函数返回时, 它会从栈中删除顶部上下文, 并使用该上下文继续执行

存储这个栈需要计算机内存中的空间. 当栈变得太大时, 会发生错误, 显示"栈空间不足(`out of stack space`)"或"递归太多(`too much recursion`)"等消息

### 可选参数

JavaScript对传入函数的参数数量几乎不做任何限制. 如果你传递了过多的参数, 多余的参数会被忽略, 而如果你传入参数过少, 遗漏的参数会被赋值为`undefined`

### 闭包

函数作为值来使用, 而且其局部绑定会在每次函数调用时重新创建

每次调用都会重新创建局部绑定, 并且不同的调用不能覆盖彼此的局部绑定

这种特性(可以引用封闭作用域中的局部绑定的特定实例)称为闭包(Closure). 引用来自周围的局部作用域的绑定的函数称为一个闭包(a closure); 

将函数值看作值, 包含它们主体中的代码和它们的创建环境. 被调用时, 函数体会看到它的创建环境而不是调用环境(think of function values as containing both the code in their body and the environment in which they are created. When called, the function body sees the environment in which it was created, not the enviroment in which it is called)

### 递归

调用它们自己的函数称为递归函数(recursion)

在典型的JavaScript实现中, 递归大约比循环版本慢三倍(vscode, 通过runcode测试, 简单函数的时间差别并不明显, 循环要比递归快一点); 通过简单循环来运行, 通常比多次调用函数开销低(但是嵌套循环的时间复杂度要高于递归的时间复杂度)

因此, 总是先写一些正确且容易理解的东西, 如果你担心速度太慢-通常不会, 可以在事后进行测量并在必要时进行改进

递归并不总是循环的低效率替代方法. 递归比循环更容易解决一些问题, 这些问题通常是需要探索或处理几个"分支"的问题, 每个"分支"可能会再次派生为更多的分支

### 添加新函数

* 写了很多相似的代码->将其封装为函数
* 需要一些新功能->命名为函数

给函数起名的难易程度取决于我们封装的函数的用途是否明确

函数应包含多少功能呢, 一个实用原则是不要故作聪明, 除非你确定会需要它.

### 函数及其副作用(side effect)

* 调用后产生副作用
* 产生返回值

