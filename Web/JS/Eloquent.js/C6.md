# The Secret Life of Objects

## 封装

将程序分成小型片段, 并让每个片段负责管理自己的状态

这种程序的不同片段通过接口(interface), 函数或绑定的有限集合交互, 它以更抽象的级别提供有用的功能, 并隐藏精确实现

程序片段使用对象建模, 接口由一组特定的方法(method)和属性(property)组成. 接口一部分属性称为公共的(public), 其他外部代码接触不到的属性称为私有的(private)

将接口与实现分离通常称为封装(encapsulation)

## 方法

每个函数都有自己的`this`绑定, 它的值依赖于它的调用方式

this 四种调用方式

`call(this, 参数数组)`

每个函数都有自己的this绑定(无法通过this访问外层函数的this, `let that=this` 保存外层`this`值)

箭头函数不同, 不绑定自己的this, 但可以看到他们周围(定义位置)作用域的`this`绑定(包含箭头函数的函数的this对象)

## 原型 prototype

`Object.getPrototypeOf()` 返回一个对象的原型

`Object prototype` 所有原型的父原型

`Object.create(object)` 创建特定原型的对象

## 类 class

类定义了对象的类型和形状--具有什么方法和属性, 这样的对象称为类的实例(instance)

原型对于属性来说很实用. 一个类的所有实例共享相同的属性值. 每个实例上的独占属性, 需要直接存储在实例对象中

为了创建一个给定类的实例, 必须使对象从正确的原型派生, 但也必须确保, 本身具有这个类的实例应该具有的属性, 这就是`constructor`的作用

`new` + 函数名(一般首字母大写) : 被视为构造器. 这意味着具有正确原型的对象会自动创建, 绑定到函数中的this, 并在函数结束时返回

所有函数都会自动获得一个名为`prototype`的属性, 默认情况下它包含一个普通的, 来自`Object.prototype`的空对象. 如果需要, 可以用新对象覆盖它

理解原型与构造器关联的方式(通过`prototype`属性), 与对象拥有原型(通过`Object.getPrototypeOf查找`)的方式之间的区别

构造函数本身是函数. 它的prototype属性拥有原型, 用于通过它创建新的实例; 新对象的原型是构造器的`prototype`属性中的对象


## 类的表示法

class关键字 允许我们在一个地方定义一个构造器和一组方法, constructor的对象提供了实际的构造器, 将绑定到名称`Rabbit`. 其他函数被打包到该构造器的原型中

`class` 是 类声明的开始, 它允许我们在一个地方定义一个构造器和一组方法. 可以在声明的大括号内写入任意数量的方法. 一个名为`constructor`的函数提供了实际的构造器, 它将绑定到类名`Rabbit`. 其他函数被打包到该构造器的原型中

<!-- ? 不绑定到具体的类名 -->
可以用作值, 没有定义绑定, 将构造器作为值生成, 可以省略类名

## 覆盖派生的属性

实例中的属性会覆盖原型中的同名属性

`Object.prototype.toString.call(this)` 调用被实例的同名属性覆盖的`toString`方法

### 映射

将值与其他值相关联的数据结构

使用简单对象会继承原型的公共属性, 作为映射不准确
解决
* null 原型创建对象 `Object.create(null)`, 创建的对象不会从`Object.prototype`派生, 对象属性名称必须是字符串
* Map()类 允许存储和运送任何类型的值
* Object.keys() 只返回实例自己的键, 而忽略原型中的键
* hasOwnProperty 替代`in`

### Map 对象

`set` `get` `has` 是`Map`对象的接口的一部分

### 多态 POLYMORPHISM

当你调用一个对象的`String(obj)`函数时(将一个值转换为一个字符串), 它会调用该对象的`toString`方法来尝试创建一个有意义的字符串

多态(`polymorphism`) 一段代码为了与某些对象协作而编写, 这些对象具有特定接口时(toString()), 任何类型的支持此接口的对象都可以使用该接口

多态代码可以处理不同的值, 只要它们支持它所期望的接口

### 符号
多个接口可能为不同的事物使用相同的属性名称

`Symbol()` 新的基本类型 `symbol` 不能创建两次相同的`symbol`, 用于属性名称

通过在属性名称周围使用方括号,可以在对象表达式和类中包含符号属性,会导致属性名称的求值

### 迭代器接口

提供给`for/of`循环的对象预计为可迭代对象(iterable), 意味着它有一个`Symbol.iterator`符号命名的方法(Symbol符号的一个方法)

调用该方法时, 返回一个对象(实例), 提供第二个接口迭代器(iterator). 这是执行迭代的实际事物. 拥有返回下一个结果的`next`方法

`value`: 下一值 {value: value1, done: false}
`done` true 到达结尾/false 仍有下一个值 {done: true}

遍历矩阵时, 通常对元素的位置以及元素本身感兴趣

### 读写器和静态 getters setters static

接口通常由方法构成, 但也可以持有非函数值的属性.

`getter` 读取器, 在方法名称前编写get定义; 读取相应属性时, 就会调用该方法

`setter` 写入器

`static` 向构造器附加属性

### 继承 inheritance

新类派生自旧类的原型, 但未`set`方法增加了一个新的定义

`extends`表示类不应该直接基于默认的`Object`原型, 而应该基于其他类. 被称为superclass. 创建的派生类为子类subclass

封装和多态可用于将代码彼此分离, 减少耦合;

但继承从根本上是将类连接在一起, 增加耦合; 继承一个类时, 要了解它如何工作

### instanceof

了解某个对象是否继承自某个特定类

### 总结