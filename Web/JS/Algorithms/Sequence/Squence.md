# 排序和搜索算法

先排序在搜索

## 排序算法

创建一个数组(列表)表示待排序和搜索的数据结构

### 冒泡排序

最简单, 但运行时间最长(嵌套循环)

比较任何两个相邻的项, 如果第一个比第二个大, 则交换它们. 元素项向上移动至正确的顺序

声明一个`length`变量存储数组的长度; 外循环从数组第一位迭代到最后一位, 控制了数组应该经过多少轮排序(每个元素都经过一轮). 然后, 内循环将从第一位迭代到倒数第二位, 内循环实际上进行当前项和下一项的比较, 如果顺序不对(当前项大于下一项), 则交换它们.

`swap()`函数, 用于交换数组元素; 使用中间项存储交换值

ES6 增强的对象属性 `[array[index1], array[index2]] = [array[index2], array[index1]];`

### 改进后的冒泡排序

从内循环中减去外循环中已跑过的轮数, 就可以避免内循环中所有不必要的比较

冒泡排序时间复杂度(O(n^2)) 嵌套循环

### 选择排序

是一种原址比较排序算法(?), 大致的思路是找到数据结构中的最小值并将其放置在第一位, 接着找到第二小的值并将其放在第二位...

外循环迭代数组, 并控制迭代轮次. 我们假设本迭代轮次的第一个值是数组最小值. 然后, 从当前i的值开始至数组结束, 我们比较是否位置j的值比当前最小值小; 如果是, 则更新最小值. 内循环结束后, 将得出数组第n小的值. 最后如果该最小值和位置i(本迭代轮次开始时假设的最小值)的值不同, 则交换它们的值.

选择排序时间复杂度(O(n^2)) 嵌套循环

### 插入排序

每次排一个数组项, 以此方式构建最后的排序数组. 假定第一项已经排序了, 接着它和第二项进行比较,判断第二项是应该待在原位还是插到第一项之前. 这样, 头两项就正确排序了; 接着和之后项进行比较, 以此类推

迭代数组给第i项找到正确的位置(算法是从第二个位置而不是位置0开始的). 然后, 用i的值来初始化一个辅助索引并将其值亦存储于一个临时变量中, 便于之后将其插入到正确的位置上. 下一步是要找到正确的位置来插入项目. 只要变量j比0大(无负值索引)并且数组中前面的值比待比较的值大, 我们就把这个值移到当前位置上并减小j. 最终该项目能插入到正确的位置上

排序小型数组时, 性能比选择排序和冒泡排序性能要好

### 归并排序

时间复杂度为O(nlog^n) (循环+内部) 可以被实际使用

> JavaScript的Array类定义了一个`sort`函数用来排序数组. ES没有定义用哪个排序算法, 所以不同厂商实现不同

归并是一种分治算法. 将原始数组切分成较小的数组, 直到每个小数组只有一个位置, 接着将小数组归并成较大的数组, 直到最后只有一个排序完毕的大数组

由于是分治的(?), 归并也是递归的

创建一个实际被执行的辅助函数`mergeSortRec` 判断数组长度是否为1作为停止条件, 长度不为1则将其二分为更小的数组(`length/2`), 最后是调用`mergo`进行合并和排序小数组的操作, 递归调用`mergeSortRec`分割数组并将结果作为参数传入`mergo`中

`mergo` 接受两个数组作为参数, 并将它们归并至一个大数组中(push). 排序发生在归并过程中. 先声明需要归并过程要创建的新数组以及用来迭代两个数组(`left/right`)所需的两个变量. 迭代过程中, 判断来自`left/right`两个数组元素大小, 将较小值存入数组中, 并递增该数组索引(另一个数组索引位置不变), 最后, 将`left`数组或right`数组所有剩余的项添加到归并数组中, 并将数组作为结果返回

### 快速排序

时间复杂度 O(nlog^n), 它的性能通常比其他复杂度相同的排序算法好, 同样使用分治的方法, 将原始数组分割为较小的数组

* 首先, 从数组中选择中间的一项作为主元
* 创建两个指针, 左边一个指向数组第一个项, 右边一个指向数组最后一个项. 移动左指针直到我们找到一个比主元大的元素, 然后, 移动右指针直到找到一个比主元小的元素, 然后交换它们, 重复这个过程, 直到左指针超过右指针. 这将使比主元小的值都排在主元之前, 比主元大的值都排在主元后--划分操作
* 算法对划分后的子数组(主元两边)重复之前的两个步骤, 直至数组排序完成(子数组为一个元素?)


### 堆排序
将数组转换为堆有序的完全二叉树
在一个堆中, 位置K的节点的父节点的位置为Math.floor(k/2), 两个子节点为2k, 2k+1; 在不使用指针的情况下, 可以通过计算数组索引在树中上下移动: 从`a[k]`向上一层就令`k=k/2` 向下一层就令`k=k*2/K*2+1`
将数组作为二叉树
<!-- ? -->
* 索引0是树的根节点
* 除根节点外, 任意节点N的父节点是N/2;
* 节点L的左节点是2*L
* 节点R的右子节点是2*R + 1;

