# Tree

非顺序数据结构, 分层数据的抽象模型

# 相关术语

一个树结构包含一系列存在父子关系的节点. 每个节点都有一个父节点(root节点除外), 以及零个或多个子节点

位于顶部为根节点(root), 每个元素称为节点, 分为内部节点和外部节点. 至少有一个子节点的节点称为内部节点. 没有子元素的节点称为外部节点或叶节点

一个节点可以有祖先和后代: 父节点, 祖父节点,.. 子节点, 孙子节点,...

子树由节点和后代构成

深度, 取决于节点的祖先节点的数量

树的高度取决于所有节点深度的最大值. 也可以分层级,(根节点为0层)

## 二叉树和二叉搜索树

二叉树中节点最多只有两个子节点: 左侧子节点, 右侧子节点

二叉搜索树(BST), 二叉树的一种; 只允许在左侧节点存储(比父节点)小的值, 在右侧节点存储(比父节点)大(等于)的值

### 创建BinarySearchTree类

声明数据结构, 和链表相同, 通过指针来表示节点之间的关系(边). 类似于双向列表, 对于树, 两个指针一个指向左侧节点, 另一个指向右侧节点

在树中, 我们称节点为键

声明一个变量控制树中根元素

方法

* insert(key) 向树中插入一个新的键
* search(key) 在树中查找一个键, 如果节点存在, 则返回true, 否则返回false
* inOrderTraverse: 通过中序遍历方式遍历所有节点
* preOrderTraverse: 通过先序遍历遍历所有节点
* postOrderTraverse: 通过后序遍历方式遍历所有节点
* min: 返回树中最小的值/键
* max: 返回树中最大的值/键
* remove(key): 从树中移除某个键

### 插入一个键

* 创建表示新节点的Node类实例.
* 验证要插入的树是否为空, 则插入节点就为这个树的根节点
* 将新节点插入在非根节点的其他位置 `insertNode`

`insertNode()` 帮助我们找到插入新节点的位置
* 如果树非空, 则需要找到插入新节点的位置. 调用`insertNode()`的参数为树的根节点和要插入的节点
* 如果新节点的键小于当前节点的键, 那么检查当前节点的左侧子节点, 如果没有左侧子节点, 就将节点插入左侧, 否则递归调用`insertNode()` 传入左侧子节点和要插入的节点
* 如果新节点的键大于当前节点, 则查询当前节点的右侧子节点, 操作同上

## 树的遍历

遍历一棵树是指访问树的每个节点并对它们进行某种操作

访问所有节点有三种方式: 中序, 先序和后序

### 中序遍历

以上行顺序访问`BST`所有节点(从最小到最大的顺序访问)

常用于对树进行排序

实现

`inOrderTraverse()` 接受一个`callback`函数作为参数. 回调函数用来定义我们对遍历到的每个节点进行的操作(也称为访问者模式)

使用中序方法遍历, 首先检查节点是否为null, 为null时则停止递归

然后, 递归调用函数访问左侧子节点, 接着对节点进行操作, 再访问右侧子节点

### 先序遍历

以优先于后代节点的顺序访问每个节点的, 先序遍历的一种应用是打印一个结构化的文档

先序遍历会先访问节点本身, 然后再访问它的左侧子节点, 最后是右侧子节点

### 后序遍历

先访问节点的后代节点, 再访问节点本身

后序遍历用于计算一个目录和它的子目录中所有文件所占空间的大小

先访问左侧子节点, 再访问右侧子节点, 最后是父节点本身

## 搜索树中的值

* 搜索最小值
* 搜索最大值
* 搜索特定值

### 搜索最小和最大值

二叉搜索树的节点值大小很明显(最左侧子节点为最小值, 最右侧子节点为最大值)

### 搜索特定的值

声明`search`方法, 调用`searchNode()`辅助函数(用于寻找一棵树或它的任意子树中的一个特定的值)

先验证传入的`node`是否合法(不为null), 否则说明键不存在, 返回false

如果搜寻的键比当前节点小, 那么继续搜索节点左侧子节点. 如果大, 那么搜索右侧子节点(二分查找)

## 移除一个节点

`remove`

接收要移除的键, 并调用`removeNode`方法, 传入`root`和要移除的键作为参数

复杂之处在于我们要处理不同的运行场景

实现

如果正在检测的节点为空, 则说明键不在树中, 返回null

如果节点不为空, 如果要找的键值比当前节点的值小, 就沿树的左边找到下一个节点. 如果比当前节点的值大, 就沿树的右边找到下一个节点

如果找到了要找的节点, 需要处理三种不同情况

* 移除一个叶节点(没有子节点)
    * 将这个节点设为null, 并返回null给父节点指向它的指针; 所以我们在函数中返回了节点的值. 另一种方法是将父节点和节点本身作为参数传入方法中

* 移除有单个子节点的节点
  * 将当前节点的引用改为子节点的引用, 并返回更新后的当前节点

* 移除有两个子节点的节点
  * 找到需要移除的节点后, 需要找到它右边子树中的最小的节点
  * 然后用右侧子树中最小的节点更新这个节点的值, 移除了节点
  * 但是此时就存在两个拥有相同键值的节点(当前节点, 原本的右子树最小节点). 就可以删除右子树中最小的节点
  * 返回更新后的节点的引用

## 自平衡树

BST存在一个问题: 取决于你添加的节点数, 树的一条边可能会非常深; 这会在某条边上添加, 移除和搜索某个节点时引起一些性能问题

改进

`Adelson-Velskii-Landi`树(AVL树) 自平衡二叉搜索树: 任何一个节点左右两侧子树的高度之差最多为1

### AVL树

需要检验它的平衡因子

在AVL树中, 需要对每个节点计算右子树高度(hr)和左子树高度(hl)的差值, 该值(hr-hl)应为0(不存在子节点), 1(只有右子节点)或 -1(只有左子节点). 结果不是这三个值之一, 则需要平衡该AVL树

#### 平衡操作

向AVL树插入节点时, 可以执行单旋转和双旋转两种平衡操作

* 右-右(RR) 向左的单旋转
  * 与平衡操作相关的节点有三个(X, Y, Z), 将节点X置于节点Y(平衡因子为-2)所在的位置(行{1})
  * 节点X的右子树保持不变
  * 将节点Y的右子节点置为节点X的左子节点
  * 将节点x的左子节点置为节点Y
* 左-左(LL) 向右的单旋转
  * 平衡有关三个节点(X, Y, Z), 将X置于Y的位置
  * 保持X的左子树不变
  * 将Y的左子节点置为节点X的右子节点
  * 将X的右子节点置为节点Y
* 左-右(LR) 向右的双旋转
* 右-左(RL) 向左的双旋转