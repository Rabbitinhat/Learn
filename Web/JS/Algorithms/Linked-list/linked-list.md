# 链表

## 链表数据结构

要存储多个元素, 数组(或列表)可能是最常用的数据结构

缺点: 数组的大小是固定的(大多数语言中), 从数组的起点或中间插入或移除项的成本很高

链表存储有序的元素集合, 但不同于数组, 链表中的元素在内存中并不是连续放置的. 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(指针或链接)组成的

相对于数组, 链表在添加或移除元素的时候不需要移动其他元素. 然而链表需要使用指针访问下一个节点; 数组可以访问任何位置的任意元素, 但链表只能从头部(表头)开始迭代列表直到找到想要的元素.

## 创建链表

* Node 实现链表的节点结构: 存储自身的值, 指向下一个节点的指针
* length 链表的长度
* head 链表头节点

方法|描述
:--|--
append(element) | 向链表尾部添加一个新的节点
insert(position, element) | 指定位置插入新的节点
remove(element) | 向链表中移除一项
indexOf(element) | 返回元素在链表中的索引, 不存在则返回 -1
removeAt(position) | 从链表特定位置移除一项
isEmpty() | 判断链表是否为空
size() | 返回链表包含元素个数
toString() | 重写继承的toString()方法, 只输出元素的值

### 添加新元素

如果链表为null, 则新添加元素为链表头部; 否则循环至链表末尾, 将末尾的元素的下一个元素指向添加元素, 长度+1;

链表最后一个节点的下一个元素始终为`null`

### 从列表中移除元素

* 移除第一个元素
* 移除第一个以外的其他元素

remove()

* 从特定位置移除一个元素
  * 判断传入位置是否在链表长度内, 否则返回null; 如果位置为0; 链表头部元素为原本头部元素的下一个元素; 位置不为0; 循环至位置处, 将前一个节点的下一个元素指向当前位置的下一个元素, 从而移除当前节点, 长度-1, 返回当前节点.
* 根据元素的值移除元素

### 任意位置插入元素

`insert(position, element)`

首先检查传入的位置, 然后如果在头部插入, 将新节点的下一个节点指向链表头部, 然后把链表头部的引用(head)改为新节点; 如果在其他位置插入; 则先循环链表节点至position处, 然后将新节点的下一个节点指向当前节点, 将当前节点的前一个节点指向新节点, 就在链表中添加一个新节点; 最后长度+1, 返回true

> 使用变量引用我们需要控制的节点非常重要, 这样就不会丢失节点之间的链接.

### 其他方法

`toString()`

先循环访问链表中的所有节点(从head开始), 然后循环访问链表中每个节点, 以当前节点是否为空(链表为空或到达链表末尾)为判断, 将节点内容拼接到字符串中, 并继续迭代下一个节点. 最后返回字符串

`indexOf(element)`

以当前节点是否为空为判断,循环访问链表, 如果节点内容为所寻值, 返回节点的位置索引. 否则, 返回-1;

`remove(element)`

*重用代码* 调用indexOf()找到元素位置, 然后调用removeAt()删除指定位置的元素.

`isEmpty(), size, getHead`

`head`变量是`LinkedList`类的私有变量, 但是如果我们需要在类的实现外部循环访问列表就需要提供一种获取类的第一个元素的方法.

## 双向链表

链接是双向的: 一个指向前一个元素, 另一个指向下一个元素

在`Node`类中, 新增`prev`指针, 也添加了保存链表最后一个节点的`tail`属性

迭代方法

* 从头到尾迭代链表
* 从尾到头

## 方法

### 任意位置插入一个新节点

在链表头部插入新节点. 如果链表为空, 则`head`和`tail`都指向这个新节点. 如果不为空, `current`变量将是对列表中第一个节点的引用. 新节点的下一个节点指向`current`, `current`的上一个节点指向新节点

在链表最后添加一个新节点, `current`引用`tail`, 新节点的前一个节点指向`current`, `current`的下一个节点指向新节点, 更新`tail`, 将其指向新节点

在链表中插入一个新元素, 迭代列表至`position`的位置, `current`引用当前节点, 新节点的下一个节点指向`current`, 新节点的上一个节点指向`previous`, `previous`的下一个节点指向新节点, `current`的上一个节点指向新节点.

> 我们可以对`insert`和`remove`进行改进, 当`position`不在链表范围中时, 可以将新节点添加到链表尾部; 性能也可做些改进, 如果`position>length/2`时, 可以从尾部开始迭代

### 任意位置移除元素

从头部移除元素

从尾部移除元素

从中间移除元素

## 循环链表

可以像链表一样只有单向引用, 也可以向双向链表一样由双向引用. 节点结构和链表相同, 最后一个元素的指向下一个元素的指针指向第一个元素(head)

## 双向循环链表

指向head元素的`tail.next` 指向`tail`的`head.prev`